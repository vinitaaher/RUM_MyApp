"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCustomerDataTracker = exports.createCustomerDataTrackerManager = exports.BYTES_COMPUTATION_THROTTLING_DELAY = exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = exports.CUSTOMER_DATA_BYTES_LIMIT = void 0;
var byteUtils_1 = require("../../tools/utils/byteUtils");
var functionUtils_1 = require("../../tools/utils/functionUtils");
var jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
var display_1 = require("../../tools/display");
var objectUtils_1 = require("../../tools/utils/objectUtils");
// RUM and logs batch bytes limit is 16KB
// ensure that we leave room for other event attributes and maintain a decent amount of event per batch
// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB
exports.CUSTOMER_DATA_BYTES_LIMIT = 3 * byteUtils_1.ONE_KIBI_BYTE;
// We observed that the compression ratio is around 8 in general, but we also want to keep a margin
// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB
// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this
// is a bit arbitrary.
exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * byteUtils_1.ONE_KIBI_BYTE;
exports.BYTES_COMPUTATION_THROTTLING_DELAY = 200;
function createCustomerDataTrackerManager(compressionStatus) {
    if (compressionStatus === void 0) { compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */; }
    var customerDataTrackers = new Map();
    var alreadyWarned = false;
    function checkCustomerDataLimit(initialBytesCount) {
        if (initialBytesCount === void 0) { initialBytesCount = 0; }
        if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {
            return;
        }
        var bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */
            ? exports.CUSTOMER_DATA_BYTES_LIMIT
            : exports.CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;
        var bytesCount = initialBytesCount;
        customerDataTrackers.forEach(function (tracker) {
            bytesCount += tracker.getBytesCount();
        });
        if (bytesCount > bytesCountLimit) {
            displayCustomerDataLimitReachedWarning(bytesCountLimit);
            alreadyWarned = true;
        }
    }
    return {
        /**
         * Creates a detached tracker. The manager will not store a reference to that tracker, and the
         * bytes count will be counted independently from other detached trackers.
         *
         * This is particularly useful when we don't know when the tracker will be unused, so we don't
         * leak memory (ex: when used in Logger instances).
         */
        createDetachedTracker: function () {
            var tracker = createCustomerDataTracker(function () { return checkCustomerDataLimit(tracker.getBytesCount()); });
            return tracker;
        },
        /**
         * Creates a tracker if it doesn't exist, and returns it.
         */
        getOrCreateTracker: function (type) {
            if (!customerDataTrackers.has(type)) {
                customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));
            }
            return customerDataTrackers.get(type);
        },
        setCompressionStatus: function (newCompressionStatus) {
            if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {
                compressionStatus = newCompressionStatus;
                checkCustomerDataLimit();
            }
        },
        getCompressionStatus: function () { return compressionStatus; },
        stop: function () {
            customerDataTrackers.forEach(function (tracker) { return tracker.stop(); });
            customerDataTrackers.clear();
        },
    };
}
exports.createCustomerDataTrackerManager = createCustomerDataTrackerManager;
function createCustomerDataTracker(checkCustomerDataLimit) {
    var bytesCountCache = 0;
    // Throttle the bytes computation to minimize the impact on performance.
    // Especially useful if the user call context APIs synchronously multiple times in a row
    var _a = (0, functionUtils_1.throttle)(function (context) {
        bytesCountCache = (0, byteUtils_1.computeBytesCount)((0, jsonStringify_1.jsonStringify)(context));
        checkCustomerDataLimit();
    }, exports.BYTES_COMPUTATION_THROTTLING_DELAY), computeBytesCountThrottled = _a.throttled, cancelComputeBytesCount = _a.cancel;
    var resetBytesCount = function () {
        cancelComputeBytesCount();
        bytesCountCache = 0;
    };
    return {
        updateCustomerData: function (context) {
            if ((0, objectUtils_1.isEmptyObject)(context)) {
                resetBytesCount();
            }
            else {
                computeBytesCountThrottled(context);
            }
        },
        resetCustomerData: resetBytesCount,
        getBytesCount: function () { return bytesCountCache; },
        stop: function () {
            cancelComputeBytesCount();
        },
    };
}
exports.createCustomerDataTracker = createCustomerDataTracker;
function displayCustomerDataLimitReachedWarning(bytesCountLimit) {
    display_1.display.warn("Customer data exceeds the recommended ".concat(bytesCountLimit / byteUtils_1.ONE_KIBI_BYTE, "KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-threshold-warning"));
}
//# sourceMappingURL=customerDataTracker.js.map